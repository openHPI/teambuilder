module TeamBuilder::Grouping
  class DistanceAlgorithm

    def initialize(features, opts = {})
      @features = features
      @opts = opts
    end

    def group!(applicants)
      cluster_participants_dynamic(applicants)
    end

    def new_team!(name, members)
      teams << Team.create(name: name, members: members)
    end

    def min_size
      @opts.fetch(:min_size, 3)
    end

    def max_size
      @opts.fetch(:max_size, 8)
    end

    def teams
      @teams ||= []
    end

    def cluster_participants_dynamic(applicants)
      starting_cluster = prepare_starting_cluster applicants
      hierarchical_clusters = prepare_for_hierarchical_clustering starting_cluster # Kmeans clustering
      clusters = create_clusters_for_team_creation hierarchical_clusters # hierarchical clustering
      build_teams_out_of_clusters clusters
    end

    def features
      @features
    end

    def prepare_starting_cluster applicants
      items = applicants.each_with_index.map { |applicant, i| Utils::Item.new(applicant, i, { features: @features }) }
      Utils::Clustering::Cluster.new(items, { features: @features })
    end


    def prepare_for_hierarchical_clustering(starting_cluster)
      # All clusters that aren't small enough yet will be send through another round of kmeans clustering, at the beginning this is only the starting cluster with all applicants
      kmeans_clusters = [starting_cluster]
      hierarchical_clusters = []
      hierarchical_cluster_max_size = 150.0
      steps = 20
      max_trys = 100

      # Setting the max limit of rundowns to 100 so the algorithm is guaranteed to end at some point (this case hasn't occured in testing yet)
      i = 0
      while kmeans_clusters.length > 0 and i < max_trys do
        i += 1
        clusters = []
        kmeans_clusters.each do |cluster|
          # The K for Kmeans defines how many clusters will be created. Since hierarchical clustering still works fine without about 150 participants,
          # The applicant length is divided by 150 to create enough clusters to split the initial cluster up into multiple smaller ones.
          # Kmeans also takes a variable called steps for the amount of iterations it will run. Wikipedia suggests 100 for this paramter but in testing 10 was more than enough.
          kmeans_clustering = Utils::Clustering::KmeansClustering.new (cluster.items.length / hierarchical_cluster_max_size).ceil,
                                                                      steps,
                                                                      { features: @features, min_size: min_size, max_size: max_size },
                                                                      true

          clusters << kmeans_clustering.cluster_participants(cluster)
        end
        # array cleanup
        clusters.flatten!

        if clusters.any? { |cluster| cluster.size < min_size }
          Rails.logger.debug { "A cluster that has to few members was created. Redoing kmeans partitioning" }
          next
        end
        kmeans_clusters = []
        # Every cluster that is 150 members large or smaller is fine to be clustered with hierarchical clustering (should only take a few seconds at max)
        # Every cluster that is bigger than that might take very long to cluster hierarchicaly so instead it's split into smaller clusters by kmeans again.
        # Runtime for kmeans should be n*n while hierarchical clustering has a runtime of n*n*n
        clusters.each do |cluster|
          if cluster.items.length <= hierarchical_cluster_max_size
            hierarchical_clusters << cluster
          else
            kmeans_clusters << cluster
          end
        end
      end
      hierarchical_clusters.flatten!
      Rails.logger.debug { "Needed #{i} kmeans clustering steps for #{hierarchical_clusters.size} clusters" }
      hierarchical_clusters
    end

    def create_clusters_for_team_creation(hierarchical_clusters)
      # Replacing each kmeans cluster with the clusters generated by hierarchical clustering. These are already the finished teams
      hierarchical_clusters.map! do |cluster|
        hierarchical_clustering = Utils::Clustering::HierarchicalClustering.new features: @features, min_size: min_size, max_size: max_size
        hierarchical_clustering.cluster_participants cluster
      end
      hierarchical_clusters.flatten
    end

    def build_teams_out_of_clusters(clusters)
      number_of_teams_digits = clusters.count.to_s.length
      clusters.each_with_index do |cluster, i|
        new_team! "Team #{i.to_s.rjust(number_of_teams_digits, '0')}", cluster.items.map(&:content) unless cluster.items.empty?
      end
      teams
    end
    def self.average_distance_in_cluster(cluster)
      return 0 if cluster.size == 1
      absolute_distance = 0.0
      cluster.items.each do |item1|
        cluster.items.each do |item2|
          absolute_distance += cluster.context[:features].calculate_distance item1.value, item2.value
        end
      end
      absolute_distance / (cluster.size**2-cluster.size)
    end

    def self.maximum_distance_in_cluster(cluster)
      maximum_distance = 0.0
      cluster.items.each do |item1|
        cluster.items.each do |item2|
          distance = cluster.context[:features].calculate_distance item1.value, item2.value
          maximum_distance = distance if distance>maximum_distance
        end
      end
      maximum_distance
    end
  end
end

